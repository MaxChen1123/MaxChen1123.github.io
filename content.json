{"posts":[{"title":"Go中的引用类型","text":"go中的函数都是传值，没有引用传递Go语言中的一些让你觉得它是引用传递的原因，是因为Go语言有值类型和引用类型，但是它们都是值传递。 值类型 - int、float、bool、string、array、sturct等 引用类型 - slice，map，channel，interface，func等 引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型 slice和arrayslice中的每个元素都是其底层array元素的引用 关于slice的append函数 通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量： 1_slice = append(_slice, r)","link":"/2023/10/03/golang/Go%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"},{"title":"关于std::move","text":"被move后的对象被move后的对象处于一种有效但是未被定义的状态，简单的来说就是可以用，但是无法保证对象里的成员变量还是什么情况，这取决于开发人员是如何编写对象类型的移动构造函数的（见 “cpp\\右值引用和移动语义.md” 的移动构造函数部分） move语句并不改变任何东西move语句并不会把原本在内存中的数据移动到其他的地方，他只是修改了变量的“标签”，让函数以对待右值的方式来对待他","link":"/2023/10/01/Cpp/%E5%85%B3%E4%BA%8Emove%E5%87%BD%E6%95%B0/"},{"title":"关于右值","text":"右值是什么右值被是程序在运行时产生临时性数据，可能被储存在寄存器中，总之其无法像左值那样取地址。 移动语义移动语义是将右值直接“移动”到一个对象 1Object O1= Object(Args...) 若有定义Object的移动构造函数，在以上代码中则会直接调用移动构造函数将赋值语句右边的构造函数产生的右值移动过来，而不是再复制一份，然后再析构右边的右值。这样做可以节省开销。 关于移动构造函数当对象里的成员变量涉及指针时，移动构造函数与复制构造函数的区别就显现出来了，以下例子： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class movedemo{public: movedemo():num(new int(0)){ cout&lt;&lt;&quot;construct!&quot;&lt;&lt;endl; } //拷贝构造函数 movedemo(const movedemo &amp;d):num(new int(*d.num)){ cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl; } //移动构造函数 movedemo(movedemo &amp;&amp;d):num(d.num){ d.num = NULL; cout&lt;&lt;&quot;move construct!&quot;&lt;&lt;endl; }public: //这里应该是 private，使用 public 是为了更方便说明问题 int *num;};int main(){ movedemo demo; cout &lt;&lt; &quot;demo2:\\n&quot;; movedemo demo2 = demo; //cout &lt;&lt; *demo2.num &lt;&lt; endl; //可以执行 cout &lt;&lt; &quot;demo3:\\n&quot;; movedemo demo3 = std::move(demo); //此时 demo.num = NULL，因此下面代码会报运行时错误 //cout &lt;&lt; *demo.num &lt;&lt; endl; return 0;} 来源：http://c.biancheng.net/view/7863.html 在这里，如果是复制构造函数的话，程序仍然会再new一个新的int变量，但是在移动构造函数里面，我们直接将其“拿“了过来，并且将右值的num变量置为NULL，这样就节省了开销。 右值引用右值引用的目的是延长右值的生命周期,防止其直接被回收。左值引用是一个左值的别名，同理，右值引用是一个右值的别名，而右值引用本身是一个左值 12int a=1;int&amp;&amp; b=1; 依我个人理解，a和b在使用上无任何区别，他们本身都是左值，而其所代表的值都是右值，且都可以被重新赋值，区别可能仅仅只是定义上的不同。 所以为什么要把一个右值传来传去个人认为这只是代码规范上的问题，因为几乎所有的构造函数中，复制构造函数的形参都是左值引用，移动构造函数的形参则都是右值引用。复制构造函数的逻辑便是传入一个左值引用，然后把他复制一份来构造一个新的对象，而右值引用便是直接把传入的对象给“移动过来” 因此如果你自己写的构造函数的形参是左值引用，但是在代码中你直接把传入的对象里的成员变量移动到了新的对象中，那这本质上其实就是一种“移动构造函数”。 在逻辑上，传入左值引用构造的意思是“这个传入的对象我以后还要用”，所以是将其复制了一份，而传入右值的意思是“这个就是个临时的对象，用完就销毁”，因此可以放心的将里面的成员变量移动到新的对象","link":"/2023/10/01/Cpp/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"},{"title":"关于方法","text":"调用方法时会发生什么接收器会复制一份调用方法的变量，因此，如果是很大的对象，建议用指针对象 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。来源 T和*T的方法集类型T有接收器为T的所有方法，类型*T有接收器为T和*T的所有方法因此，以下代码无法通过编译： 1234567891011121314151617181920package maintype People interface { speak() talk()}type Student struct{ name string}func (*Student) speak() {}func (Student) talk(){ }func main() { var peo People = Student{}} 因为类型T只有接收器为T的方法，故Student只拥有talk函数，而没有speak函数，因此无法实现People接口 但是为什么类型T可以调用*T的方法？12345678910111213141516171819202122type T struct { a int}func (t T) M1() { t.a = 10}func (t *T) M2() { t.a = 11}func main() { var t1 T t1.M1() t1.M2() var t2 = &amp;T{} t2.M1() t2.M2() //以上代码都是可以的} 因为类型T在调用*T的方法时，编译器会自动将T取地址，变成&amp;T，这是go语言的一个语法糖——也因此，类型T调用*T的方法的前提条件是上述语法糖可以生效，即类型T是可以取地址的，以下代码就不会编译通过： 12345func main() { T{}.M2() // 编译器错误：cannot call pointer method M2 on T (&amp;T{}).M1() // OK (&amp;T{}).M2() // OK} 顺带一提，为什么&amp;T{}可以？因为&amp;T{}与new(T)没有区别 As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and &amp;File{} are equivalent. 来源：Effective Go","link":"/2023/10/03/golang/%E5%85%B3%E4%BA%8Ego%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"为什么我开始在个人网站写博客","text":"为什么开始在自己的个人网站写博客？这个问题其实有两部分，第一，为什么我要有自己的个人网站，第二，为什么开始写博客，以下是我思考后总结出来的理由，应该可以对可能打算拥有自己的个人博客网站的你提供一点想法 为什么想要有自己的个人网站一直以来对这件事的憧憬你大概听过什么“你作为一个程序员竟然没有自己的个人网站”之类的带着一丝不屑的感叹，虽然程序员必须要有自己的个人网站这种说法存在争议，毕竟你很难说一个没有自己的网站的程序员就不是优秀的程序员，但因为我总能看到各种技术大佬们精美的个人网站（通常他们的头像都是一位穿着衬衫且带着自信的笑容的标准”senior engineer”形象），这也不免让我坚定了拥有个人网站的想法–就好像这是成为一名技术大佬的必经之路一样。 再加上从小就高强度网上冲浪的我一直很羡慕可以在偌大的互联网世界拥有一块“私人领地”的人，于是乎，我就在2023年的国庆节假日期间跟着网上的傻瓜教程上线了自己的网站，说实话，建一个个人博客网站这件事真的比我想象的要简单许多–当然，前提是你打算用现有的框架（感谢开源）。 可以很自由地写自己想写的东西我本人现在不是很喜欢在社交媒体上发表自己的观点。 一方面是觉得这真的没什么必要，毕竟如果你的同学都是在动态里发自己的轻松惬意的大学生活，而你却整天在上面发一些别人无法理解也不感兴趣的内容时，这从某种角度上来说是一种自私且无趣的行为。 另一方面是因为目前社交媒体的审查制度让我们无法直接对某些事情发表自己的看法，与其绞尽脑汁地删减、修改自己想要发出的内容还不如不发。 但是在自己的个人网站，这都是由你说了算，如果别人不喜欢你的内容，TA大可以直接退出，毕竟大家是自愿进入的，你也不用担心自己的发的东西会不会突然就没了，这种可以放开手脚的自由的感觉真的是很难得的（虽然还是不能发一些很“过分”的东西）。 为什么要写博客锻炼自己的写作能力我的写作能力很差，真的很差，我相信愿意读到这里的你要么是对我很感兴趣，要么就是应该有着异于常人的耐心，不然很难在我杂乱无序的文笔中坚持下来，感谢你 :) 。 小学时代的我基本上就是靠背诵和阅读作文范文撑过每一个语文作文题目的。中学时代，我应对作文题的写作套路就是在竭尽自己所有的有逻辑的语言后开始疯狂输出各种没有意义的、重复的语句来凑字数，最后再写一个以“为了中华民族的伟大复兴”为开头的结尾段。 可想而知，十多年的在校语文学习经历并没有让我锻炼出良好的写作能力。但是在上大学后，我逐渐意识到拥有优秀的表达和写作能力的重要性，因此打算通过写博客来锻炼自己的表达和写作。 帮助自己发现错误在我开始写博客之前，我没有记笔记的习惯，主要是觉得单纯地将知识摘抄下来没有作用–我自己不愿意看，别人也应该不愿意看。 但当我开始尝试写一两篇技术类型的博客时，我才发现很多自认为的“因为理所当然，所以不去深究”的知识我都没有弄明白，因为不想写下有误导性的内容，我会仔细地上网搜寻验证博客中的可能出现的错误，在这过程中我可以更好地审视并发现自己对一些概念理解上的问题，这能帮助我发现错误和增强对复杂概念的理解。 同时，在写博客的过程中那种不断地输出自己的知识的感觉，以及博客完成后放在网页上的样子，都可以给我带来很大的成就感。 尽自己所能帮助别人每当我在学习或者是编程的过程中遇到各种复杂的概念或一长串的报错时，我都会习惯性的打开搜索引擎并祈祷可以看到某位已经解决这个问题的人写的博客–我一直都是这么做的，也因此很感谢那些愿意把自己遇到的问题和解决方法分享出来的人。 如果互联网上的每个人都指望在遇到问题后可以有他人来帮助，但是自己又不愿花时间来写下一篇博客帮助他人，那如今富有活力的程序员社区是不可能形成的，我很推崇这种自发的互助精神，这也是我开始写博客的一个重要原因。","link":"/2023/10/13/%E6%9D%82%E9%A1%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"title":"头文件互相引用怎么处理","text":"头文件相互include会怎样会导致编译器遇到循环依赖问题，从而编译出错，make项目时会出现报错，表示两个.h文件中的class都未定义 怎么解决如遇以下情况 1234567//a.h#include&quot;b.h&quot;class A{...}//b.h#include&quot;a.h&quot;class B{...} 可将代码改为 12345678910//a.h#include&quot;b.h&quot;class B{...}//b.hclass A; //不完全声明class b{...}//b.cpp#include&quot;a.h&quot; //在b.cpp而不是b.h中包含a.h","link":"/2023/10/01/Cpp/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"},{"title":"简中-繁中程序词汇对应","text":"简中-繁中 声明-宣告 访问-尋訪 变量-變數 程序-程式 代码-程式碼 信息-資訊 类型-型態 数据-資料 算法-演算法 实现-實作","link":"/2023/10/01/%E6%9D%82%E9%A1%B9/%E7%AE%80%E4%B8%AD-%E7%B9%81%E4%B8%AD%E7%A8%8B%E5%BA%8F%E8%AF%8D%E6%B1%87%E5%AF%B9%E5%BA%94/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"引用","slug":"引用","link":"/tags/%E5%BC%95%E7%94%A8/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"右值","slug":"右值","link":"/tags/%E5%8F%B3%E5%80%BC/"},{"name":"方法","slug":"方法","link":"/tags/%E6%96%B9%E6%B3%95/"},{"name":"碎碎念","slug":"碎碎念","link":"/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"语言","slug":"语言","link":"/tags/%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"}],"pages":[]}