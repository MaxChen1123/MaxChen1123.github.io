{"posts":[{"title":"Go中的引用类型","text":"go中的函数都是传值，没有引用传递Go语言中的一些让你觉得它是引用传递的原因，是因为Go语言有值类型和引用类型，但是它们都是值传递。 值类型 - int、float、bool、string、array、sturct等 引用类型 - slice，map，channel，interface，func等 引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型 slice和arrayslice中的每个元素都是其底层array元素的引用 关于slice的append函数 通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量： 1_slice = append(_slice, r)","link":"/2023/10/03/golang/Go%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"},{"title":"关于方法","text":"调用方法时会发生什么接收器会复制一份调用方法的变量，因此，如果是很大的对象，建议用指针对象 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。来源 T和*T的方法集类型T有接收器为T的所有方法，类型*T有接收器为T和*T的所有方法因此，以下代码无法通过编译： 1234567891011121314151617181920package maintype People interface { speak() talk()}type Student struct{ name string}func (*Student) speak() {}func (Student) talk(){ }func main() { var peo People = Student{}} 因为类型T只有接收器为T的方法，故Student只拥有talk函数，而没有speak函数，因此无法实现People接口 但是为什么类型T可以调用*T的方法？12345678910111213141516171819202122type T struct { a int}func (t T) M1() { t.a = 10}func (t *T) M2() { t.a = 11}func main() { var t1 T t1.M1() t1.M2() var t2 = &amp;T{} t2.M1() t2.M2() //以上代码都是可以的} 因为类型T在调用*T的方法时，编译器会自动将T取地址，变成&amp;T，这是go语言的一个语法糖——也因此，类型T调用*T的方法的前提条件是上述语法糖可以生效，即类型T是可以取地址的，以下代码就不会编译通过： 12345func main() { T{}.M2() // 编译器错误：cannot call pointer method M2 on T (&amp;T{}).M1() // OK (&amp;T{}).M2() // OK} 顺带一提，为什么&amp;T{}可以？因为&amp;T{}与new(T)没有区别 As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and &amp;File{} are equivalent. 来源：Effective Go","link":"/2023/10/03/golang/%E5%85%B3%E4%BA%8Ego%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"},{"title":"RVO和NRVO","text":"现在的编译器都支持RVO，大部分支持NRVO，并且在我们编译代码时都是默认开启，如果要关闭需要在编译选项中加上-fno-elide-constructors.如: 1g++ -fno-elide-constructors main.cpp -o main 如果没有RVO和NRVO会怎样通过-fno-elide-constructors命令关闭优化，编译运行下面的代码 123456789101112131415161718192021#include&lt;iostream&gt;class B{public: B(){ std::cout&lt;&lt;&quot;Constructor of B&quot;&lt;&lt;std::endl; } B(const B&amp; b){ std::cout&lt;&lt;&quot;Copy Constructor of B&quot;&lt;&lt;std::endl; } B(B&amp;&amp; b){ std::cout&lt;&lt;&quot;Move Constructor of B&quot;&lt;&lt;std::endl; }};B fun(){ B t_b; return t_b;}int main(){ B _b=fun();} 输出： 123Constructor of BMove Constructor of BMove Constructor of B 可以看到在关闭了优化后,B类型的对象被创建后,还进行了两次移动构造，一次将其移动到返回值，一次将返回值移动到变量_b. 至于为什么第一次的移动构造不是复制构造,可以参见我的另一篇博客《为什么构造返回值时是移动构造而不是复制构造》。 RVORVO即Return Value Optimization，是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作。 1234567891011121314151617181920#include&lt;iostream&gt;class B{public: B(){ std::cout&lt;&lt;&quot;Constructor of B&quot;&lt;&lt;std::endl; } B(const B&amp; b){ std::cout&lt;&lt;&quot;Copy Constructor of B&quot;&lt;&lt;std::endl; } B(B&amp;&amp; b){ std::cout&lt;&lt;&quot;Move Constructor of B&quot;&lt;&lt;std::endl; }};B fun(){ return B();}int main(){ B _b=fun();} 对上面的程序编译运行，只会输出“Constructor of B” NRVONRVO，即Named Return Value Optimization，可以将有名字的返回的局部变量同样进行优化。 123456789101112131415161718192021#include&lt;iostream&gt;class B{public: B(){ std::cout&lt;&lt;&quot;Constructor of B&quot;&lt;&lt;std::endl; } B(const B&amp; b){ std::cout&lt;&lt;&quot;Copy Constructor of B&quot;&lt;&lt;std::endl; } B(B&amp;&amp; b){ std::cout&lt;&lt;&quot;Move Constructor of B&quot;&lt;&lt;std::endl; }};B fun(){ B t_b; return t_b;}int main(){ B _b=fun();} 对上面的程序编译运行，同样只会输出“Constructor of B”","link":"/2023/10/20/Cpp/RVO%E5%92%8CNRVO/"},{"title":"using一个类成员的报错","text":"报错有如下代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class ZZ{public: void print1() { std::cout &lt;&lt; &quot;hello\\n&quot;; }};class YY : public ZZ{public: void print() { using ZZ::print1; //error: 'ZZ' is not a namespace or unscoped enum using ZZ::print1 print1(); }};int main(){ YY temp; temp.print(); getchar(); return 0;} 报错显示ZZ不是一个命名空间或者枚举类型（ZZ实际上是一个类名）,但是将print1写成这样便可通过编译。 123456public: using ZZ::print1; void print() { print1(); } 这样也可以通过编译： 123void print(){ using std::cout;} 原因 A using-declaration for a class member shall be a member-declaration. 也就是如果想要using一个类成员的话，只能把using语句放置在类的作用域里面，不可以放在local作用域中。但是using命名空间和枚举类型可以放置在local作用域中。","link":"/2023/10/18/Cpp/using%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8A%A5%E9%94%99/"},{"title":"关于std::move","text":"被move后的对象被move后的对象处于一种有效但是未被定义的状态，简单的来说就是可以用，但是无法保证对象里的成员变量还是什么情况，这取决于开发人员是如何编写对象类型的移动构造函数的（见 “cpp\\右值引用和移动语义.md” 的移动构造函数部分） move语句并不改变任何东西move语句并不会把原本在内存中的数据移动到其他的地方，他只是修改了变量的“标签”，让函数以对待右值的方式来对待他","link":"/2023/10/01/Cpp/%E5%85%B3%E4%BA%8Emove%E5%87%BD%E6%95%B0/"},{"title":"为什么构造返回值时是移动构造而不是复制构造","text":"问题the code is here: 123456789101112131415161718192021#include&lt;iostream&gt;class B{public: B(){ std::cout&lt;&lt;&quot;Constructor of B&quot;&lt;&lt;std::endl; } B(const B&amp; b){ std::cout&lt;&lt;&quot;Copy Constructor of B&quot;&lt;&lt;std::endl; } B(B&amp;&amp; b){ std::cout&lt;&lt;&quot;Move Constructor of B&quot;&lt;&lt;std::endl; }};B fun(){ B t_b; return t_b;}int main(){ B _b=fun();} and then I used g++ to compile and then ran the code: 12g++ -std=c++11 -fno-elide-constructors constructor.cpp -o constructor.\\constructor.exe the output is: 123Constructor of BMove Constructor of BMove Constructor of B I’ve already add “-fno-elide-constructors” to tell the compiler do not use RVO/NRVO, and “-std=c++11” to use c++11 standard. There are still two move-constructions. I know the second one is called to move-construct _b. But the first one is confusing. t_b is a lvalue so it should be used by copy-constructor to copy-construct the temporary returned value, I think. 原因 When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object’s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. — end note ] 即使在没有开启RVO和NRVO的情况下，如果返回的源对象不是函数参数，且他是一个lvalue时，编译器会把要返回的对象当作rvalue来进行重载解析（overload resolution），如果成功，那就会调用移动构造函数；如果重载解析失败的话，或者被匹配到的构造函数的参数不是右值引用时，再把他当lvalue来重载解析。 例子: 1234567891011121314151617class Thing {public: Thing(); ~Thing(); Thing(Thing&amp;&amp;);private: Thing(const Thing&amp;);};Thing f(bool b) { Thing t; if (b) throw t; // OK: Thing(Thing&amp;&amp;) used (or elided) to throw t return t; // OK: Thing(Thing&amp;&amp;) used (or elided) to return t}Thing t2 = f(false); // OK: Thing(Thing&amp;&amp;) used (or elided) to construct t2 来源","link":"/2023/10/20/Cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0/"},{"title":"名字查找（name lookup)","text":"编译器为了查找函数，会进行名字查找，编译器会从local作用域开始查找，再到类的作用域及其父类作用域，最后再到全局作用域。开始查找的是函数名而非函数签名，也就是只关心函数的名字而不考虑其参数和返回值类型，在找到当前作用域中所有匹配的函数名后，再进行参数的匹配，选取形参与实参最接近的那个作为匹配出的函数（也就是最佳匹配） 例子12345678910111213141516class B{public: int func1(); int func1(int);};class D:public B{public: int func1();};int main(){ D d; d.func1(1); //error: no matching function for call to 'D::func1(int)' return 0; } 当调用func1(1)时，因为D::func1已经覆盖了父类中的B::func1，编译器根据函数名在D的作用域找到了D::func1，因此停止继续向外围作用域查找，但是又匹配不到D::func1(int)，因此报错。 我们可以使用using将B::func1直接暴露出来，这样编译器就可以找到B::func1(int)了 1234567891011121314151617class B{public: int func1(); int func1(int);};class D:public B{public: using B::func1; int func1();};int main(){ D d; d.func1(1); return 0; } 最佳匹配在函数调用时，首先对函数进行名字查找，在找到一个同名函数（假设不会出现命名冲突）时，编译器并不会停止查找，而是继续找出当前作用域的所有重载函数，然后根据最佳匹配规则，确定实际调用的函数。不同作用域的同名函数并不会被视为重载。最直观的例子是，类内的函数与类外的同名函数并不会形成重载。 在名字查找完成且不存在编译错误的情况下，编译器便开始确定与调用匹配得最好的函数。最佳匹配原则也很简单，实参类型与形参类型越接近，匹配得越好。 注意 在看到是否有个函数可取用之前， C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。比如在向父类作用域查找时，即使是private的成员函数也可能被匹配（虽然不可以被调用）。","link":"/2023/10/18/Cpp/%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE/"},{"title":"关于右值","text":"右值是什么右值被是程序在运行时产生临时性数据，可能被储存在寄存器中，总之其无法像左值那样取地址。 移动语义移动语义是将右值直接“移动”到一个对象 1Object O1= Object(Args...) 若有定义Object的移动构造函数，在以上代码中则会直接调用移动构造函数将赋值语句右边的构造函数产生的右值移动过来，而不是再复制一份，然后再析构右边的右值。这样做可以节省开销。 关于移动构造函数当对象里的成员变量涉及指针时，移动构造函数与复制构造函数的区别就显现出来了，以下例子： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class movedemo{public: movedemo():num(new int(0)){ cout&lt;&lt;&quot;construct!&quot;&lt;&lt;endl; } //拷贝构造函数 movedemo(const movedemo &amp;d):num(new int(*d.num)){ cout&lt;&lt;&quot;copy construct!&quot;&lt;&lt;endl; } //移动构造函数 movedemo(movedemo &amp;&amp;d):num(d.num){ d.num = NULL; cout&lt;&lt;&quot;move construct!&quot;&lt;&lt;endl; }public: //这里应该是 private，使用 public 是为了更方便说明问题 int *num;};int main(){ movedemo demo; cout &lt;&lt; &quot;demo2:\\n&quot;; movedemo demo2 = demo; //cout &lt;&lt; *demo2.num &lt;&lt; endl; //可以执行 cout &lt;&lt; &quot;demo3:\\n&quot;; movedemo demo3 = std::move(demo); //此时 demo.num = NULL，因此下面代码会报运行时错误 //cout &lt;&lt; *demo.num &lt;&lt; endl; return 0;} 来源：http://c.biancheng.net/view/7863.html 在这里，如果是复制构造函数的话，程序仍然会再new一个新的int变量，但是在移动构造函数里面，我们直接将其“拿“了过来，并且将右值的num变量置为NULL，这样就节省了开销。 右值引用右值引用的目的是延长右值的生命周期,防止其直接被回收。左值引用是一个左值的别名，同理，右值引用是一个右值的别名，而右值引用本身是一个左值 12int a=1;int&amp;&amp; b=1; 依我个人理解，a和b在使用上无任何区别，他们本身都是左值，而其所代表的值都是右值，且都可以被重新赋值，区别可能仅仅只是定义上的不同。 所以为什么要把一个右值传来传去个人认为这只是代码规范上的问题，因为几乎所有的构造函数中，复制构造函数的形参都是左值引用，移动构造函数的形参则都是右值引用。复制构造函数的逻辑便是传入一个左值引用，然后把他复制一份来构造一个新的对象，而右值引用便是直接把传入的对象给“移动过来” 因此如果你自己写的构造函数的形参是左值引用，但是在代码中你直接把传入的对象里的成员变量移动到了新的对象中，那这本质上其实就是一种“移动构造函数”。 在逻辑上，传入左值引用构造的意思是“这个传入的对象我以后还要用”，所以是将其复制了一份，而传入右值的意思是“这个就是个临时的对象，用完就销毁”，因此可以放心的将里面的成员变量移动到新的对象","link":"/2023/10/01/Cpp/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/"},{"title":"头文件互相引用怎么处理","text":"头文件相互include会怎样会导致编译器遇到循环依赖问题，从而编译出错，make项目时会出现报错，表示两个.h文件中的class都未定义 怎么解决如遇以下情况 1234567//a.h#include&quot;b.h&quot;class A{...}//b.h#include&quot;a.h&quot;class B{...} 可将代码改为 12345678910//a.h#include&quot;b.h&quot;class B{...}//b.hclass A; //不完全声明class b{...}//b.cpp#include&quot;a.h&quot; //在b.cpp而不是b.h中包含a.h","link":"/2023/10/01/Cpp/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"},{"title":"指针常量与常量指针","text":"指针常量声明如下： 12int * const p=&amp;a; constexpr int* p=&amp;a; //常量表达式 表示指针本身是一个常量，不可以更改指针本身的内容，也就是不可以更改指针所指向的对象。注意，其本身是一个常量，所以必须在声明的同时对其进行初始化。 常量指针声明如下： 1const int * p; int const * p; 表示指针所指向的值是一个常量，不可以通过此指针来更改所指向的内容。 指向常量的常指针就像这样，是以上两者的结合： 12const int* const p=&amp;a;constexpr const int* p=&amp;a; p本身是一个常量，同时指向一个常量。顺便一提，其实我觉得这个可以叫“常量指针常量”（奥利奥lol）。 注意在王刚和杨巨峰翻译的《C++ Primer》第五版中，将上述常量指针翻译为指向常量的指针，指针常量翻译为常量指针，请注意区分。","link":"/2023/10/19/Cpp/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/"},{"title":"默认构造函数","text":"默认构造函数是什么 默认构造函数是可以无实参调用的构造函数（以空参数列表定义，或为每个形参提供默认实参而定义） 以空参数列表定义： 123456789class A{ public: A(){x=0;} int x;};int main(){ A a; } 为每个形参提供默认实参而定义： 123456789class A{ public: A(int _x=1){x=_x;} int x;};int main(){ A a; } 但是上述两者不可以同时出现： 12345678910class A{ public: A(){x=0;} A(int _x=1){x=_x;} int x;};int main(){ A a; //编译器报错： error: call of overloaded 'A()' is ambiguous} 隐式默认构造函数如果你没有声明任何形式的构造函数，那么编译器将提供隐式的默认构造函数（又有叫合成的默认构造函数），在隐式的默认构造函数中，具有类类型的成员通过运行各自的默认构造函数来进行初始化，而内置类型的成员会被初始化成0（静态对象）或者随机数比如下面的例子： 123456789101112131415161718192021class A{public: A(bool _isTrue=true, int _num = 0){ isTrue = _isTrue; num = _num; }; //默认构造函数 bool isTrue; int num;};class B{public: A a;//类A含有默认构造函数 int b; //...};int main(){ B b; //隐式默认构造函数，其中成员变量a以类型A的默认构造函数构造 //成员变量b则被初始化为随机值 return 0;} 注意不能通过如下语句来调用默认构造函数 1B b(); 因为B b();可以被解释为函数声明或是对默认构造函数的调用。 因为 C++ 分析程序更偏向于声明，因此表达式会被视为函数声明。","link":"/2023/10/15/Cpp/%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"为什么我开始写博客","text":"帮助自己发现错误在我开始写博客之前，我没有记笔记的习惯，主要是觉得单纯地将知识摘抄下来没有作用——我自己不愿意看，别人也应该不愿意看。 但当我开始尝试写一两篇技术类型的博客时，我才发现很多自认为的“因为理所当然，所以不去深究”的知识我都没有弄明白，因为不想写下有误导性的内容，我会仔细地上网搜寻验证博客中的可能出现的错误，在这过程中我可以更好地审视并发现自己对一些概念理解上的问题，这能帮助我发现错误和增强对复杂概念的理解。 同时，在写博客的过程中那种不断地输出自己的知识的感觉，以及博客完成后放在网页上的样子，都可以给我带来很大的成就感。 锻炼自己的写作能力我的写作能力很差，真的很差，我相信愿意读到这里的你要么是对我很感兴趣，要么就是应该有着异于常人的耐心，不然很难在我杂乱无序的文笔中坚持下来，感谢你 :) 。 小学时代的我基本上就是靠背诵和阅读作文范文撑过每一个语文作文题目的。中学时代，我应对作文题的写作套路就是在竭尽自己所有的有逻辑的语言后开始疯狂输出各种没有意义的、重复的语句来凑字数，最后再写一个以“为了中华民族的伟大复兴”为开头的结尾段。 可想而知，十多年的在校语文学习经历并没有让我锻炼出良好的写作能力。但是在上大学后，我逐渐意识到拥有优秀的表达和写作能力的重要性，因此打算通过写博客来锻炼自己的表达和写作。 尽自己所能帮助别人每当我在学习或者是编程的过程中遇到各种复杂的概念或一长串的报错时，我都会习惯性的打开搜索引擎并祈祷可以看到某位已经解决这个问题的人写的博客——我一直都是这么做的，也因此很感谢那些愿意把自己遇到的问题和解决方法分享出来的人。 如果互联网上的每个人都指望在遇到问题后可以有他人来帮助，但是自己又不愿花时间来写下一篇博客帮助他人，那如今富有活力的程序员社区是不可能形成的，我很推崇这种自发的互助行为，这也是我开始写博客的一个重要原因。","link":"/2023/10/13/%E6%9D%82%E9%A1%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"title":"简中-繁中程序词汇对应","text":"简中-繁中 声明-宣告 访问-尋訪 变量-變數 程序-程式 代码-程式碼 信息-資訊 类型-型態 数据-資料 算法-演算法 实现-實作","link":"/2023/10/01/%E6%9D%82%E9%A1%B9/%E7%AE%80%E4%B8%AD-%E7%B9%81%E4%B8%AD%E7%A8%8B%E5%BA%8F%E8%AF%8D%E6%B1%87%E5%AF%B9%E5%BA%94/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"引用","slug":"引用","link":"/tags/%E5%BC%95%E7%94%A8/"},{"name":"方法","slug":"方法","link":"/tags/%E6%96%B9%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"报错","slug":"报错","link":"/tags/%E6%8A%A5%E9%94%99/"},{"name":"右值","slug":"右值","link":"/tags/%E5%8F%B3%E5%80%BC/"},{"name":"构造函数","slug":"构造函数","link":"/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"观点","slug":"观点","link":"/tags/%E8%A7%82%E7%82%B9/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"},{"name":"语言","slug":"语言","link":"/tags/%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"想法","slug":"想法","link":"/categories/%E6%83%B3%E6%B3%95/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"}],"pages":[]}