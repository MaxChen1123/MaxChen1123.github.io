<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Max Chen&#039;s</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Max Chen&#039;s"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Max Chen&#039;s"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Max Chen&#039;s"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Max Chen&#039;s"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Max Chen"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Max Chen's","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Max Chen"},"publisher":{"@type":"Organization","name":"Max Chen's","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Max Chen&#039;s" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Visit my GitHub profile" href="https://github.com/MaxChen1123"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-19T16:00:00.000Z" title="2023/10/20 00:00:00">2023-10-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-20T07:39:11.040Z" title="2023/10/20 15:39:11">2023-10-20</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">2 minutes read (About 353 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/20/Cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0/">为什么构造返回值时是移动构造而不是复制构造</a></p><div class="content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>the code is here:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Copy Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(B&amp;&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Move Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">B <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B t_b;</span><br><span class="line">    <span class="keyword">return</span> t_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B _b=<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and then I used g++ to compile and then ran the code:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -fno-elide-constructors constructor.cpp -o constructor</span><br><span class="line">.\constructor.exe</span><br></pre></td></tr></table></figure>

<p>the output is:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor of B</span><br><span class="line">Move Constructor of B</span><br><span class="line">Move Constructor of B</span><br></pre></td></tr></table></figure>
<p>I’ve already add “-fno-elide-constructors” to tell the compiler do not use RVO&#x2F;NRVO, and “-std&#x3D;c++11” to use c++11 standard. There are still two move-constructions. I know the second one is called to move-construct _b. But the first one is confusing. t_b is a lvalue so it should be used by copy-constructor to copy-construct the temporary returned value, I think.</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><blockquote>
<p>When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object’s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided.  — end note ]</p>
</blockquote>
<p>即使在没有开启RVO和NRVO的情况下，如果返回的源对象不是函数参数，且他是一个lvalue时，编译器会把要返回的对象当作rvalue来进行重载解析（overload resolution），如果成功，那就会调用移动构造函数；如果重载解析失败的话，或者被匹配到的构造函数的参数不是右值引用时，再把他当lvalue来重载解析。</p>
<p>例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Thing</span>();</span><br><span class="line">  ~<span class="built_in">Thing</span>();</span><br><span class="line">  <span class="built_in">Thing</span>(Thing&amp;&amp;);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Thing</span>(<span class="type">const</span> Thing&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Thing <span class="title">f</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;</span><br><span class="line">  Thing t;</span><br><span class="line">  <span class="keyword">if</span> (b)</span><br><span class="line">    <span class="keyword">throw</span> t;                    <span class="comment">// OK: Thing(Thing&amp;&amp;) used (or elided) to throw t</span></span><br><span class="line">  <span class="keyword">return</span> t;                     <span class="comment">// OK: Thing(Thing&amp;&amp;) used (or elided) to return t</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thing t2 = <span class="built_in">f</span>(<span class="literal">false</span>);            <span class="comment">// OK: Thing(Thing&amp;&amp;) used (or elided) to construct t2</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://timsong-cpp.github.io/cppwp/n3337/class.copy#32">来源</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-19T16:00:00.000Z" title="2023/10/20 00:00:00">2023-10-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-20T07:42:27.467Z" title="2023/10/20 15:42:27">2023-10-20</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">a minute read (About 183 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/20/Cpp/RVO%E5%92%8CNRVO/">RVO和NRVO</a></p><div class="content"><p>现在的编译器都支持RVO，大部分支持NRVO，并且在我们编译代码时都是默认开启，如果要关闭需要在编译选项中加上<code>-fno-elide-constructors</code>.<br>如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fno-elide-constructors main.cpp -o main</span><br></pre></td></tr></table></figure>
<h1 id="如果没有RVO和NRVO会怎样"><a href="#如果没有RVO和NRVO会怎样" class="headerlink" title="如果没有RVO和NRVO会怎样"></a>如果没有RVO和NRVO会怎样</h1><p>通过<code>-fno-elide-constructors</code>命令关闭优化，编译运行下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Copy Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(B&amp;&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Move Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">B <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B t_b;</span><br><span class="line">    <span class="keyword">return</span> t_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B _b=<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor of B</span><br><span class="line">Move Constructor of B</span><br><span class="line">Move Constructor of B</span><br></pre></td></tr></table></figure>
<p>可以看到在关闭了优化后,B类型的对象被创建后,还进行了两次移动构造，一次将其移动到返回值，一次将返回值移动到变量<code>_b</code>.</p>
<p>至于为什么第一次的移动构造不是复制构造,可以参见我的另一篇博客《为什么构造返回值时是移动构造而不是复制构造》。</p>
<h1 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h1><p>RVO即Return Value Optimization，是一种编译器优化技术，可以把通过函数返回创建的临时对象给”去掉”，然后可以达到少调用拷贝构造的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Copy Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(B&amp;&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Move Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">B <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B _b=<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面的程序编译运行，只会输出“Constructor of B”</p>
<h1 id="NRVO"><a href="#NRVO" class="headerlink" title="NRVO"></a>NRVO</h1><p>NRVO，即Named Return Value Optimization，可以将有名字的返回的局部变量同样进行优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Copy Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">B</span>(B&amp;&amp; b)&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Move Constructor of B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">B <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B t_b;</span><br><span class="line">    <span class="keyword">return</span> t_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B _b=<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面的程序编译运行，同样只会输出“Constructor of B”</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-18T16:00:00.000Z" title="2023/10/19 00:00:00">2023-10-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-20T04:48:08.442Z" title="2023/10/20 12:48:08">2023-10-20</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">2 minutes read (About 282 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/19/Cpp/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/">指针常量与常量指针</a></p><div class="content"><h1 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h1><p>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p=&amp;a;  </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* p=&amp;a;  <span class="comment">//常量表达式</span></span><br></pre></td></tr></table></figure>
<p>表示指针本身是一个常量，不可以更改指针本身的内容，也就是不可以更改指针所指向的对象。<br><br>注意，其本身是一个常量，所以必须在声明的同时对其进行初始化。</p>
<h1 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h1><p>声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p; <span class="type">int</span> <span class="type">const</span> * p;</span><br></pre></td></tr></table></figure>
<p>表示指针所指向的值是一个常量，不可以通过此指针来更改所指向的内容。</p>
<h1 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h1><p>就像这样，是以上两者的结合：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p=&amp;a;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>* p=&amp;a; </span><br></pre></td></tr></table></figure>
<p>p本身是一个常量，同时指向一个常量。顺便一提，其实我觉得这个可以叫“常量指针常量”（奥利奥lol）。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>在王刚和杨巨峰翻译的《C++ Primer》第五版中，将上述常量指针翻译为指向常量的指针，指针常量翻译为常量指针，请注意区分。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-17T16:00:00.000Z" title="2023/10/18 00:00:00">2023-10-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-18T12:02:29.418Z" title="2023/10/18 20:02:29">2023-10-18</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">a minute read (About 200 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/18/Cpp/using%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8A%A5%E9%94%99/">using一个类成员的报错</a></p><div class="content"><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZZ</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YY</span> : <span class="keyword">public</span> ZZ</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> ZZ::print1;  <span class="comment">//error: &#x27;ZZ&#x27; is not a namespace or unscoped enum using ZZ::print1</span></span><br><span class="line">        <span class="built_in">print1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    YY temp;</span><br><span class="line">    temp.<span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错显示ZZ不是一个<strong>命名空间</strong>或者<strong>枚举类型</strong>（ZZ实际上是一个类名）,但是将print1写成这样便可通过编译。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> ZZ::print1;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="built_in">print1</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样也可以通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><blockquote>
<p>A using-declaration for a class member shall be a member-declaration.</p>
</blockquote>
<p>也就是如果想要using一个类成员的话，只能把using语句放置在类的作用域里面，不可以放在local作用域中。但是using命名空间和枚举类型可以放置在local作用域中。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-17T16:00:00.000Z" title="2023/10/18 00:00:00">2023-10-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-18T13:18:34.785Z" title="2023/10/18 21:18:34">2023-10-18</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">4 minutes read (About 631 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/18/Cpp/%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE/">名字查找（name lookup)</a></p><div class="content"><p>编译器为了查找函数，会进行名字查找，编译器会从local作用域开始查找，再到类的作用域及其父类作用域，最后再到全局作用域。开始查找的是<strong>函数名</strong>而非函数签名，也就是只关心函数的名字而不考虑其参数和返回值类型，在找到当前作用域中所有匹配的函数名后，再进行参数的匹配，选取形参与实参最接近的那个作为匹配出的函数（也就是<strong>最佳匹配</strong>）</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">func1</span>(<span class="number">1</span>);  <span class="comment">//error: no matching function for call to &#x27;D::func1(int)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>func1(1)</code>时，因为<code>D::func1</code>已经覆盖了父类中的<code>B::func1</code>，编译器根据函数名在D的作用域找到了<code>D::func1</code>，因此停止继续向外围作用域查找，但是又匹配不到<code>D::func1(int)</code>，因此报错。<br></p>
<p>我们可以使用<code>using</code>将<code>B::func1</code>直接暴露出来，这样编译器就可以找到<code>B::func1(int)</code>了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> B::func1;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">func1</span>(<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h2><p>在函数调用时，首先对函数进行名字查找，在找到一个同名函数（假设不会出现命名冲突）时，编译器并不会停止查找，而是继续找出当前作用域的所有重载函数，然后根据最佳匹配规则，确定实际调用的函数。不同作用域的同名函数并不会被视为重载。最直观的例子是，类内的函数与类外的同名函数并不会形成重载。<br></p>
<p>在名字查找完成且不存在编译错误的情况下，编译器便开始确定与调用匹配得最好的函数。最佳匹配原则也很简单，实参类型与形参类型越接近，匹配得越好。<br></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>在看到是否有个函数可取用之前， C++ 首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。比如在向父类作用域查找时，即使是private的成员函数也可能被匹配（虽然不可以被调用）。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-14T16:00:00.000Z" title="2023/10/15 00:00:00">2023-10-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-15T15:42:09.481Z" title="2023/10/15 23:42:09">2023-10-15</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">3 minutes read (About 445 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/15/Cpp/%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">默认构造函数</a></p><div class="content"><h1 id="默认构造函数是什么"><a href="#默认构造函数是什么" class="headerlink" title="默认构造函数是什么"></a>默认构造函数是什么</h1><blockquote>
<p>默认构造函数是可以无实参调用的构造函数（以空参数列表定义，或为每个形参提供默认实参而定义）<br></p>
</blockquote>
<p>以空参数列表定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每个形参提供默认实参而定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _x=<span class="number">1</span>)&#123;x=_x;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述两者<strong>不可以同时出现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;x=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _x=<span class="number">1</span>)&#123;x=_x;&#125;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;      <span class="comment">//编译器报错： error: call of overloaded &#x27;A()&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="隐式默认构造函数"><a href="#隐式默认构造函数" class="headerlink" title="隐式默认构造函数"></a>隐式默认构造函数</h1><p>如果你没有声明任何形式的构造函数，那么编译器将提供隐式的默认构造函数（又有叫合成的默认构造函数），在隐式的默认构造函数中，具有类类型的成员通过运行各自的默认构造函数来进行初始化，而内置类型的成员会被初始化成0（静态对象）或者随机数<br><br>比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">bool</span> _isTrue=<span class="literal">true</span>, <span class="type">int</span> _num = <span class="number">0</span>)&#123; isTrue = _isTrue; num = _num; &#125;; <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="type">bool</span> isTrue;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A a;<span class="comment">//类A含有默认构造函数</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;    <span class="comment">//隐式默认构造函数，其中成员变量a以类型A的默认构造函数构造</span></span><br><span class="line">            <span class="comment">//成员变量b则被初始化为随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>不能通过如下语句来调用默认构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">B <span class="title">b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为<code>B b();</code>可以被解释为函数声明或是对默认构造函数的调用。 因为 C++ 分析程序更偏向于声明，因此表达式会被视为函数声明。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-12T16:00:00.000Z" title="2023/10/13 00:00:00">2023-10-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-20T07:46:11.606Z" title="2023/10/20 15:46:11">2023-10-20</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%83%B3%E6%B3%95/">想法</a></span><span class="level-item">5 minutes read (About 777 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/13/%E6%9D%82%E9%A1%B9/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/">为什么我开始写博客</a></p><div class="content"><h2 id="帮助自己发现错误"><a href="#帮助自己发现错误" class="headerlink" title="帮助自己发现错误"></a>帮助自己发现错误</h2><p>在我开始写博客之前，我没有记笔记的习惯，主要是觉得单纯地将知识摘抄下来没有作用——我自己不愿意看，别人也应该不愿意看。<br></p>
<p>但当我开始尝试写一两篇技术类型的博客时，我才发现很多自认为的“因为理所当然，所以不去深究”的知识我都没有弄明白，因为不想写下有误导性的内容，我会仔细地上网搜寻验证博客中的可能出现的错误，在这过程中我可以更好地审视并发现自己对一些概念理解上的问题，这能帮助我发现错误和增强对复杂概念的理解。<br></p>
<p>同时，在写博客的过程中那种不断地输出自己的知识的感觉，以及博客完成后放在网页上的样子，都可以给我带来很大的成就感。</p>
<h2 id="锻炼自己的写作能力"><a href="#锻炼自己的写作能力" class="headerlink" title="锻炼自己的写作能力"></a>锻炼自己的写作能力</h2><p>我的写作能力很差，真的很差，我相信愿意读到这里的你要么是对我很感兴趣，要么就是应该有着异于常人的耐心，不然很难在我杂乱无序的文笔中坚持下来，感谢你 :) 。<br></p>
<p>小学时代的我基本上就是靠背诵和阅读作文范文撑过每一个语文作文题目的。中学时代，我应对作文题的写作套路就是在竭尽自己所有的有逻辑的语言后开始疯狂输出各种没有意义的、重复的语句来凑字数，最后再写一个以“为了中华民族的伟大复兴”为开头的结尾段。<br></p>
<p>可想而知，十多年的在校语文学习经历并没有让我锻炼出良好的写作能力。但是在上大学后，我逐渐意识到拥有优秀的表达和写作能力的重要性，因此打算通过写博客来锻炼自己的表达和写作。</p>
<h2 id="尽自己所能帮助别人"><a href="#尽自己所能帮助别人" class="headerlink" title="尽自己所能帮助别人"></a>尽自己所能帮助别人</h2><p>每当我在学习或者是编程的过程中遇到各种复杂的概念或一长串的报错时，我都会习惯性的打开搜索引擎并祈祷可以看到某位已经解决这个问题的人写的博客——我一直都是这么做的，也因此很感谢那些愿意把自己遇到的问题和解决方法分享出来的人。<br></p>
<p>如果互联网上的每个人都指望在遇到问题后可以有他人来帮助，但是自己又不愿花时间来写下一篇博客帮助他人，那如今富有活力的程序员社区是不可能形成的，我很推崇这种自发的互助行为，这也是我开始写博客的一个重要原因。<br></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-02T16:00:00.000Z" title="2023/10/3 00:00:00">2023-10-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-13T14:46:06.654Z" title="2023/10/13 22:46:06">2023-10-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">2 minutes read (About 362 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/03/golang/Go%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">Go中的引用类型</a></p><div class="content"><h1 id="go中的函数都是传值，没有引用传递"><a href="#go中的函数都是传值，没有引用传递" class="headerlink" title="go中的函数都是传值，没有引用传递"></a>go中的函数都是传值，没有引用传递</h1><p>Go语言中的一些让你觉得它是引用传递的原因，是因为Go语言有<code>值类型</code>和<code>引用类型</code>，但是它们都是值传递。</p>
<ul>
<li><p>值类型 - int、float、bool、string、<strong>array</strong>、<strong>sturct</strong>等</p>
</li>
<li><p>引用类型 - slice，map，channel，interface，func等</p>
</li>
</ul>
<p>引用类型作为参数时,称为浅拷贝,形参改变,实参数跟随变化.因为传递的是地址,形参和实参都指向同一块地址<br>值类型作为参数时,称为深拷贝,形参改变,实参不变,因为传递的是值的副本,形参会新开辟一块空间,与实参指向不同<br>如果希望值类型数据在修改形参时实参跟随变化,可以把参数设置为指针类型</p>
<h1 id="slice和array"><a href="#slice和array" class="headerlink" title="slice和array"></a>slice和array</h1><p>slice中的每个元素都是其底层array元素的引用</p>
<h2 id="关于slice的append函数"><a href="#关于slice的append函数" class="headerlink" title="关于slice的append函数"></a>关于slice的append函数</h2><blockquote>
<p>通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_slice = <span class="built_in">append</span>(_slice, r)</span><br></pre></td></tr></table></figure>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-10-02T16:00:00.000Z" title="2023/10/3 00:00:00">2023-10-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-13T13:57:31.711Z" title="2023/10/13 21:57:31">2023-10-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Go/">Go</a></span><span class="level-item">4 minutes read (About 622 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/03/golang/%E5%85%B3%E4%BA%8Ego%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/">关于方法</a></p><div class="content"><h1 id="调用方法时会发生什么"><a href="#调用方法时会发生什么" class="headerlink" title="调用方法时会发生什么"></a>调用方法时会发生什么</h1><p>接收器会复制一份调用方法的变量，因此，如果是很大的对象，建议用指针对象</p>
<blockquote>
<p>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。<a target="_blank" rel="noopener" href="https://golang-china.github.io/gopl-zh/ch6/ch6-02.html#:~:text=%E5%81%9A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%82-,%E5%9C%A8,-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAmethod">来源</a></p>
</blockquote>
<h1 id="T和-T的方法集"><a href="#T和-T的方法集" class="headerlink" title="T和*T的方法集"></a>T和*T的方法集</h1><p>类型T有接收器为T的所有方法，类型*T有接收器为T和*T的所有方法<br><br>因此，以下代码无法通过编译：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak()</span><br><span class="line">    talk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Student)</span></span> speak() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Student)</span></span> talk()&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型T只有接收器为T的方法，故Student只拥有talk函数，而没有speak函数，因此无法实现People接口</p>
<h1 id="但是为什么类型T可以调用-T的方法？"><a href="#但是为什么类型T可以调用-T的方法？" class="headerlink" title="但是为什么类型T可以调用*T的方法？"></a>但是为什么类型T可以调用*T的方法？</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M1() &#123;</span><br><span class="line">    t.a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M2() &#123;</span><br><span class="line">    t.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t1 T</span><br><span class="line">    t1.M1()</span><br><span class="line">    t1.M2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t2 = &amp;T&#123;&#125;</span><br><span class="line">    t2.M1()</span><br><span class="line">    t2.M2()</span><br><span class="line">    <span class="comment">//以上代码都是可以的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为类型T在调用*T的方法时，编译器会自动将T取地址，变成&amp;T，这是go语言的一个<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/MethodSets#:~:text=a%20unique%20name.-,Calls,-%3A%20A%20method%20call">语法糖</a>——也因此，类型T调用*T的方法的前提条件是上述语法糖可以生效，即类型T是可以取地址的，以下代码就不会编译通过：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    T&#123;&#125;.M2() <span class="comment">// 编译器错误：cannot call pointer method M2 on T</span></span><br><span class="line">    (&amp;T&#123;&#125;).M1()  <span class="comment">// OK</span></span><br><span class="line">    (&amp;T&#123;&#125;).M2()  <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺带一提，为什么-T-可以？"><a href="#顺带一提，为什么-T-可以？" class="headerlink" title="顺带一提，为什么&amp;T{}可以？"></a>顺带一提，为什么&amp;T{}可以？</h2><p>因为&amp;T{}与new(T)没有区别</p>
<blockquote>
<p>As a limiting case, if a composite literal contains no fields at all, it creates a zero value for the type. The expressions new(File) and &amp;File{} are equivalent.</p>
</blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://go.dev/doc/effective_go#composite_literals:~:text=fd%2C%20name%3A%20name%7D-,As,-a%20limiting%20case">Effective Go</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-09-30T16:00:00.000Z" title="2023/10/1 00:00:00">2023-10-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-13T13:46:41.474Z" title="2023/10/13 21:46:41">2023-10-13</time></span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">a minute read (About 175 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/01/Cpp/%E5%85%B3%E4%BA%8Emove%E5%87%BD%E6%95%B0/">关于std::move</a></p><div class="content"><h1 id="被move后的对象"><a href="#被move后的对象" class="headerlink" title="被move后的对象"></a>被move后的对象</h1><p>被move后的对象处于一种<strong>有效但是未被定义的状态</strong>，简单的来说就是可以用，但是无法保证对象里的成员变量还是什么情况，这取决于开发人员是如何编写对象类型的移动构造函数的（见 “cpp\右值引用和移动语义.md” 的移动构造函数部分）</p>
<h1 id="move语句并不改变任何东西"><a href="#move语句并不改变任何东西" class="headerlink" title="move语句并不改变任何东西"></a>move语句并不改变任何东西</h1><p>move语句并不会把原本在内存中的数据移动到其他的地方，他只是修改了变量的“<strong>标签</strong>”，让函数以对待右值的方式来对待他</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://avatars.githubusercontent.com/u/120114772?v=4" alt="Max Chen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Max Chen</p><p class="is-size-6 is-block">自由的保证是什么?是对自己不再感到羞耻。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Anhui China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/MaxChen1123" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/MaxChen1123"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%83%B3%E6%B3%95/"><span class="level-start"><span class="level-item">想法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E9%A1%B9/"><span class="level-start"><span class="level-item">杂项</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-19T16:00:00.000Z">2023-10-20</time></p><p class="title"><a href="/2023/10/20/Cpp/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0/">为什么构造返回值时是移动构造而不是复制构造</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-19T16:00:00.000Z">2023-10-20</time></p><p class="title"><a href="/2023/10/20/Cpp/RVO%E5%92%8CNRVO/">RVO和NRVO</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-18T16:00:00.000Z">2023-10-19</time></p><p class="title"><a href="/2023/10/19/Cpp/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/">指针常量与常量指针</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/Cpp/using%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%8A%A5%E9%94%99/">using一个类成员的报错</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-10-17T16:00:00.000Z">2023-10-18</time></p><p class="title"><a href="/2023/10/18/Cpp/%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE/">名字查找（name lookup)</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B3%E5%80%BC/"><span class="tag">右值</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%95%E7%94%A8/"><span class="tag">引用</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%83%B3%E6%B3%95/"><span class="tag">想法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%A5%E9%94%99/"><span class="tag">报错</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E9%92%88/"><span class="tag">指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%B9%E6%B3%95/"><span class="tag">方法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><span class="tag">构造函数</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E8%AF%91/"><span class="tag">编译</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%A7%82%E7%82%B9/"><span class="tag">观点</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E8%A8%80/"><span class="tag">语言</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Max Chen&#039;s" height="28"></a><p class="is-size-7"><span>&copy; 2023 Max Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>